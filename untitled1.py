# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NKM8eVRKPaE1K0dpA8jxhfSyyMJDrf5Z
"""

def gridsearch(model,trainset,precision,epsilon,phi=1):
  solu=1,1,1
  accu_max=accuracy(model(1,1,1),trainset)
  for alpha in range(1,2,precision):
    for beta in range(1,2,precision):
      for gama in range(1,2,precision):
        if np.abs(alpha*beta**2*gama**2 - 2)<=epsilon:
          accu = accuracy(model(alpha,beta,gama),trainset)
          if accu>accu_max:
            accu_max= accu
            solu=alpha,beta,gama
    return solu

def accuracy(net,batch_size,cuda=True):
  r=net.resolution
  transform = transforms.Compose(
    [
     transforms.Resize(size=(r, r)),
     transforms.ToTensor(),
     transforms.Normalize((0.5,), (0.5,)),
  ])
  testset = torchvision.datasets.CIFAR10(root="./data", train=True, transform=transform, download=True)
  testloader = torch.utils.data.DataLoader(testset,batch_size=batch_size,shuffle=False,num_workers=2)
  net.eval()
  correct = 0
  total = 0
  loss = 0
  with torch.no_grad():
    for data in test_loader:
      images, labels = data
      if cuda:
        images = images.type(torch.cuda.FloatTensor)
        labels = labels.type(torch.cuda.LongTensor)
        outputs = net(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()
        # if total > 100:
        # break
  net.train()
  print('Accuracy of the network on the test images: %d %%' % (100 * correct / total))
  # return (100.0 * correct / total, loss/total)
  return 100.0 * correct/total